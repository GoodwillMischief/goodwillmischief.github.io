# LeHACK Wargame - Hidden : going further

## Intro
LeHACK is a hacking conference held every year in Pantin, close to Paris.
At the end of the event, a CTF named "Wargame" is organized
and lasts all night long.

During the 2025 LeHACK Wargame, the goal of the RE challenge named "Hidden"
was to understand a cypher function stored in a dynamically-linked library.

## During the Wargame
The dynamically linked-library is named `hidden.so` and the binary `hidden.bin`.

During the Wargame, I simply set a breakpoint where the library functions are called,
and when I jumped in the function, GDB printed the library storage location in the system.

    (gdb) b* 0x1000013fd
    Breakpoint 1 at 0x1000013fd
    (gdb) r
    ...
    Breakpoint 1, 0x00000001000013fd in ?? ()
    (gdb) si
    0x00007ffff7fba160 in check () from /tmp/hidden.so
    (gdb) 

`hidden.so` is "hidden" in `/tmp`.

## But how the hell this libray appeared in my system ??
With @remsflems, we were surprised that a library had appeared in
our system and asked ourselves how it could happen.
My theory was that one of the functions called before `main` had been modified.

First let's try to find the first `hidden.so` appearance during the execution.

**Command**

    strace -o strace.out ./hidden.bin
    cat strace.out | grep hidden.so

**Output**

    ...
    unlink("/tmp/hidden.so")
    ...

Then I looked to the `syscalls` executed around:

**Command**

    cat strace.out | grep -B 3 -A 3 ./hidden.so

**Output**
    ...
    mprotect(0x681ad7526000, 8192, PROT_READ) = 0
    prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=16384*1024, rlim_max=RLIM64_INFINITY}) = 0
    munmap(0x681ad74b3000, 226179)          = 0
    unlink("/tmp/hidden.so")                = -1 ENOENT (Aucun fichier ou dossier de ce nom)
    openat(AT_FDCWD, "/tmp/hidden.so", O_RDWR|O_CREAT, 0777) = 3
    write(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\20\0\0\0\0\0\0"..., 14296) = 14296
    close(3)                                = 0
    readlink("/proc/self/exe", "/home/user_one/ctf/lehack/wargam"..., 4095) = 55
    ...

My job now will be to find the functions that are susceptible to make these `syscalls` in one
of the functions called before `main`.
In radare2 we can see `entry.init0` and `entry.init1`.
    
    [0x00001570]> afl
    ...
    0x00001560    5     56 entry.init0
    0x000011b0    9    464 entry.init1
    ...

As you can see the `entry.init0` function is really short and, believe me, there is nothing
interesting in it. Unlikely, `entry.init1` seems REAAAALLY interesting once disassembled.

> I do not put the entire disassembly here because it would be too long.

We can for example see calls to the `open`, `write`, `close` and `readlink` functions.
Something else that is really interesting is that before a large amount of these calls,
a custom function (labelled `fcn.00001570` by radare2) is called.

**Example**

    call fcn.00001570
    mov rdi, rbp
    mov rsi, rax
    call sym.imp.strcmp


Here you can see the whole disassembly of this function:

        0x00001570      4989f8         mov r8, rdi
        0x00001573      85f6           test esi, esi
    ┌─< 0x00001575      7e1c           jle 0x1593
    │   0x00001577      8d4eff         lea ecx, [rsi - 1]
    │   0x0000157a      4889f8         mov rax, rdi
    │   0x0000157d      488d4c0f01     lea rcx, [rdi + rcx + 1]
    |   0x00001582      660f1f440000   nop word [rax + rax]
    │┌> 0x00001588      3010           xor byte [rax], dl
    │╎  0x0000158a      4883c001       add rax, 1
    │╎  0x0000158e      4839c8         cmp rax, rcx
    │└< 0x00001591      75f5           jne 0x1588
    └─> 0x00001593      4c89c0         mov rax, r8
        0x00001596      c3             ret

Once reversed, I conclude that it is a simple `xor_by_x` function that could have prototype
a C prototype as follows:
```c
    char* xor_by_x(char* data, int dataSize, int x);
```
Let's check the theory by extracting the bytes xored before the `write` function call that seems
to write the `hidden.so` file in the system.

    ...
    lea rdi, str.oUV
    mov edx, 0x10
    mov esi, 0x37d8
    call fcn.00001570
    mov edi, ebp
    mov edx, 0x37d8
    mov rsi, rax
    call sym.imp.write
    ...

We can see that it takes `0x37d8` values stored at a place named `str.oUV` by radare2, and then XOR them 
by `0x10`. Now, I've to find the offset where values pointed by `str.oUV` are in `hidden.bin`:

**In radare2**

    [0x000011b0]> px 10 @ str.oUV 
    - offset -  C0C1 C2C3 C4C5 C6C7 C8C9 CACB CCCD CECF  0123456789ABCDEF
    0x000043c0  6f55 5c56 1211 1110 1010                 oU\V......

**In the terminal**

    user_one@machine:hidden $ xxd ./hidden.bin | grep 6f55
    000033c0: 6f55 5c56 1211 1110 1010 1010 1010 1010  oU\V............

Lets now write a little bit of code in order to extracts and XOR everything.
```c
    #include <stdio.h>
    #include <stdlib.h>

    #define LIBOFFSET 0x33c0
    #define LIBSIZE 0x37d8

    int main(){
        FILE *inFile = fopen("./hidden.bin", "rb"); 
        FILE *outFile = fopen("./extracted_lib.so", "wb"); 

        fseek(inFile, LIBOFFSET, SEEK_SET);
        
        unsigned char *libBytes = malloc(LIBSIZE);
        
        fread(libBytes, 1, LIBSIZE, inFile);

        for(int i=0; i<LIBSIZE; i++){
            libBytes[i] = libBytes[i] ^ 0x10;
        }

        fwrite(libBytes, 1, LIBSIZE, outFile);

        free(libBytes);
        fclose(inFile);
        fclose(outFile);
        return 0;
   }
```
Once the code compiled and executed, we can see that what we extracted is the lib given by the `hidden.bin` during
the challenge.

    user_one@machine:hidden $ sha512sum hidden.so 
    9fd6ba37925801f4abd45dcc2396c534e094ec7a6d3da33b13bc58c967a7ae94e02caf781ad82f6c5d2ccd039840670362c2e369cf2b10d9bc9a8cda84e8393e  hidden.so
    user_one@machine:hidden $ sha512sum extracted_lib.so
    9fd6ba37925801f4abd45dcc2396c534e094ec7a6d3da33b13bc58c967a7ae94e02caf781ad82f6c5d2ccd039840670362c2e369cf2b10d9bc9a8cda84e8393e  extracted_lib.so
